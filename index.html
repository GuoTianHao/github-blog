<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>郭天昊的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="郭天昊的个人博客">
<meta property="og:url" content="https://guotianhao.github.io/github-blog/index.html">
<meta property="og:site_name" content="郭天昊的个人博客">
<meta property="og:locale">
<meta property="article:author" content="郭天昊">
<meta property="article:tag" content="java,redis,vagrant">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/github-blog/atom.xml" title="郭天昊的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/github-blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/github-blog/css/style.css">

  
    
<link rel="stylesheet" href="/github-blog/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/github-blog/" id="logo">郭天昊的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/github-blog/">Home</a>
        
          <a class="main-nav-link" href="/github-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/github-blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://guotianhao.github.io/github-blog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-数据库常用的事务隔离级别都有哪些？都是什么原理？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T23:17:30.505Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>任何支持事务的数据库，都必须具备四个特性，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），也就是我们常说的事务ACID，这样才能保证事务（（Transaction）中数据的正确性。</p>
<p>而事务的隔离性就是指，多个并发的事务同时访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务间要相互进行隔离。</p>
<p>如果没有事务隔离，会出现什么样的情况呢？</p>
<p>假设我们现在有这样一张表（T），里面记录了很多牛人的名字，我们不进行事务的隔离看看会发生什么呢？</p>
<p>第一天，事务A访问了数据库，它干了一件事情，往数据库里加上了新来的牛人的名字，但是没有提交事务。</p>
<p>insert into T values (4, ‘牛D’);</p>
<p>这时，来了另一个事务B，他要查询所有牛人的名字。</p>
<p>select Name from T;</p>
<p>这时，如果没有事务之间没有有效隔离，那么事务B返回的结果中就会出现“牛D”的名字。这就是“脏读（dirty read）”。</p>
<p>第二天，事务A访问了数据库，他要查看ID是1的牛人的名字，于是执行了</p>
<p>select Name from T where ID = 1;</p>
<p>这时，事务B来了，因为ID是1的牛人改名字了，所以要更新一下，然后提交了事务。</p>
<p>update T set Name = ‘不牛’ where ID = 1;</p>
<p>接着，事务A还想再看看ID是1的牛人的名字，于是又执行了</p>
<p>select Name from T where ID = 1;</p>
<p>结果，两次读出来的ID是1的牛人名字竟然不相同，这就是不可重复读（unrepeatable read）。</p>
<p>第三天，事务A访问了数据库，他想要看看数据库的牛人都有哪些，于是执行了</p>
<p>select * from T;</p>
<p>这时候，事务B来了，往数据库加入了一个新的牛人。</p>
<p>insert into T values(4, ‘牛D’);</p>
<p>这时候，事务A忘了刚才的牛人都有哪些了，于是又执行了。</p>
<p>select * from T;</p>
<p>结果，第一次有三个牛人，第二次有四个牛人。</p>
<p>相信这个时候事务A就蒙了，刚才发生了什么？这种情况就叫“幻读（phantom problem）”。</p>
<p>为了防止出现脏读、不可重复读、幻读等情况，我们就需要根据我们的实际需求来设置数据库的隔离级别。</p>
<p>数据库都有哪些隔离级别呢？</p>
<p>一般的数据库，都包括以下四种隔离级别：</p>
<p>读未提交（Read Uncommitted）<br>读提交（Read Committed）<br>可重复读（Repeated Read）<br>串行化（Serializable）<br>如何使用这些隔离级别，那就需要根据业务的实际情况来进行判断了。</p>
<p>我们接下来就看看这四个隔离级别的具体情况</p>
<p>读未提交（Read Uncommitted）</p>
<p>读未提交，顾名思义，就是可以读到未提交的内容。</p>
<p>因此，在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。</p>
<p>如无特殊情况，基本是不会使用这种隔离级别的。</p>
<p>读提交（Read Committed）</p>
<p>读提交，顾名思义，就是只能读到已经提交了的内容。</p>
<p>这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：</p>
<p>select * from T where ID=2 lock in share mode;</p>
<p>select * from T where ID=2 for update;</p>
<p>不然，普通的查询是不会加锁的。</p>
<p>那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？</p>
<p>这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”</p>
<p>假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞，这种情况下，并发能力就相当的差。</p>
<p>而“快照读”就可以完成高并发的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。</p>
<p>可重复读(Repeated Read)</p>
<p>可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。</p>
<p>在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。</p>
<p>串行化（Serializable）</p>
<p>这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。</p>
<p>这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p>
<p>总结一下</p>
<p>为什么会出现“脏读”？因为没有“select”操作没有规矩。</p>
<p>为什么会出现“不可重复读”？因为“update”操作没有规矩。</p>
<p>为什么会出现“幻读”？因为“insert”和“delete”操作没有规矩。</p>
<p>“读未提（Read Uncommitted）”能预防啥？啥都预防不了。</p>
<p>“读提交（Read Committed）”能预防啥？使用“快照读（Snapshot Read）”，避免“脏读”，但是可能出现“不可重复读”和“幻读”。</p>
<p>“可重复读（Repeated Red）”能预防啥？使用“快照读（Snapshot Read）”，锁住被读取记录，避免出现“脏读”、“不可重复读”，但是可能出现“幻读”。</p>
<p>“串行化（Serializable）”能预防啥？排排坐，吃果果，有效避免“脏读”、“不可重复读”、“幻读”，不过效果谁用谁知道。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/" data-id="ckqio8h3t0007k8ve0ei4bkru" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-使用密钥连接服务器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/30/%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T23:17:30.494Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="使用密钥连接服务器"><a href="#使用密钥连接服务器" class="headerlink" title="使用密钥连接服务器"></a>使用密钥连接服务器</h1><ol>
<li><p>生成密钥，执行命令:</p>
<p><code>ssh-keygen -t rsa</code></p>
</li>
<li><p>会出现提示，需要输入两边密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:x7zGmw3Hvn4EC14M9jMC7oX5VW5doNyTRbdI5RU01+0 root@localhost.localdomain</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|             .+BX|</span><br><span class="line">|        . o..o+oX|</span><br><span class="line">|       . = +o++=.|</span><br><span class="line">|        +o+ O o.E|</span><br><span class="line">|       .S++= *   |</span><br><span class="line">|        .ooo. .  |</span><br><span class="line">|          = o.   |</span><br><span class="line">|         . B  .  |</span><br><span class="line">|          o.=o   |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure></li>
<li><p>此时执行命令ls</p>
<p><code>[root@localhost .ssh]# ls</code></p>
<p>目录文件内容如下：</p>
<p><code>authorized_keys  id_rsa  id_rsa.pub</code></p>
<p>注：两个文件生成到 /root/.ssh下面，如果没有.ssh文件夹则新建</p>
</li>
<li><p>执行命令mv ./id_rsa.pub ./authorized_keys把公钥内容移动到authorized_keys</p>
</li>
<li><p>修改配置文件</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">PubkeyAuthentication yes 启用公钥认证</span><br><span class="line">AuthorizedKeysFile /root/.ssh/authorized_keys 公钥文件位置</span><br><span class="line">PasswordAuthentication no 禁止密码验证登录</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="6">
<li><p>重启ssh服务</p>
<p><code>service sshd restart</code></p>
</li>
<li><p>用Xshell工具连接，密钥选择生成的id_rsa，输入密码，连接成功！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Connecting to 127.0.0.1:2222...</span><br><span class="line">Connection established.</span><br><span class="line">To escape to local shell, press &#x27;Ctrl+Alt+]&#x27;.</span><br><span class="line"></span><br><span class="line">WARNING! The remote SSH server rejected X11 forwarding request.</span><br><span class="line">Last login: Sat Jul 25 02:43:21 2020 from 10.0.2.2</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/30/%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="ckqio8h3o0004k8veb46zhp28" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-谷粒商成笔记-docker mysql&amp;redis环境搭建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/30/%E8%B0%B7%E7%B2%92%E5%95%86%E6%88%90%E7%AC%94%E8%AE%B0-docker%20mysql&redis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T23:17:30.474Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1.mysql"></a>1.mysql</h3><p>下载mysql镜像:<br>  systemctl daemon-reload<br>  systemctl restart docker<br>  docker pull mysql:5.7</p>
<p>启动mysql容器：<br>  命令：</p>
<p>  docker run -p 3306:3306 –name mysql <br> -v /mydata/mysql/log:/var/log/mysql <br> -v /mydata/mysql/data:/var/lib/mysql <br> -v /mydata/mysql/conf:/etc/mysql <br> -e MYSQL_ROOT_PASSWORD=root <br> -d mysql:5.7</p>
<p> 含义：<br> docker run -p 3306（linux环境端口）:3306（对应容器端口） –name mysql（容器名） <br>-v(目录挂载) /mydata/mysql/log:/var/log/mysql \（linux文件系统跟容器目录挂载，类似快捷方式）<br>-v /mydata/mysql/data:/var/lib/mysql <br>-v /mydata/mysql/conf:/etc/mysql <br>-e MYSQL_ROOT_PASSWORD=root <br>-d mysql:5.7</p>
<p>进入docker内部环境：<br>docker exec -it mysql /bin/bash<br>一个容器就是一个完整得linux</p>
<p>显示mysql相关路径：<br>root@ce14300907e9:/# whereis mysql<br>mysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql</p>
<p>设置mysql配置文件，修改字符编码：<br>[client]<br>default-character-set=utf-8</p>
<p>[mysql]<br>default-character-set=utf-8</p>
<p>[mysqld]<br>init_connect=’SET collation_connection = utf8_unicode_ci’<br>init_connect=’SET NAMES utf8’<br>character-set-server=utf-8<br>collation-server=utf8_unicode_ci<br>skip-character-set-client-handshake<br>skip-name-resolve</p>
<p>每次自动启动：<br>docker update mysql –restart=always<br>每次虚拟机重启，容器都会自动启动</p>
<h3 id="2-redis"><a href="#2-redis" class="headerlink" title="2.redis"></a>2.redis</h3><p>运行dicker redis实例：<br>docker exec -it redis redis-cli<br>启动redis容器：<br>docker run -p 6379:6379 –name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/30/%E8%B0%B7%E7%B2%92%E5%95%86%E6%88%90%E7%AC%94%E8%AE%B0-docker%20mysql&redis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" data-id="ckqio8h3u0008k8vedp6k9epg" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-谷粒商成-nacos&amp;配置中心" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/30/%E8%B0%B7%E7%B2%92%E5%95%86%E6%88%90-nacos&%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T23:17:30.462Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="使用nacos-config作为配置中心统一管理配置"><a href="#使用nacos-config作为配置中心统一管理配置" class="headerlink" title="使用nacos config作为配置中心统一管理配置"></a>使用nacos config作为配置中心统一管理配置</h2><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-start-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建一个-bootstrap-properties"><a href="#2-创建一个-bootstrap-properties" class="headerlink" title="2 创建一个 bootstrap.properties"></a>2 创建一个 bootstrap.properties</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.application.name=xxx</span></span><br><span class="line"><span class="string">spring.cloud.nacos.config.server-addr=127.0.0.1:8848</span></span><br></pre></td></tr></table></figure>

<h4 id="3-给配置中心添加数据集"><a href="#3-给配置中心添加数据集" class="headerlink" title="3.给配置中心添加数据集"></a>3.给配置中心添加数据集</h4><p>默认 应用名.properties</p>
<h4 id="4-动态获取配置"><a href="#4-动态获取配置" class="headerlink" title="4.动态获取配置"></a>4.动态获取配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//动态获取刷新配置</span></span><br><span class="line"><span class="meta">@Value</span> <span class="comment">//获取配置值</span></span><br></pre></td></tr></table></figure>

<p>如果配置中心和应用配置文件都配置相同得项了，<strong>优先使用配置中心得配置。</strong></p>
<h5 id="1-命名空间："><a href="#1-命名空间：" class="headerlink" title="1.命名空间："></a>1.命名空间：</h5><p>配置空间，默认public（保留空间）</p>
<p>开发：dev，测试：test，生产：prod，利用命名空间做环境隔离    </p>
<p>给应用配置组，配置文件格式，命名空间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.cloud.nacos.config.server-addr=127.0.0.1:8848</span></span><br><span class="line"><span class="string">spring.cloud.nacos.config.group=product</span></span><br><span class="line"><span class="string">spring.cloud.nacos.config.file-extension=yaml</span></span><br><span class="line"><span class="string">spring.cloud.nacos.config.namespace=**命名空间uuid，不能写命名空间名字**</span></span><br></pre></td></tr></table></figure>



<h5 id="2-配置分组"><a href="#2-配置分组" class="headerlink" title="2.配置分组"></a>2.配置分组</h5><p>默认所有都为DEFAULT_GROUP</p>
<p><strong>结构大概为以下：</strong></p>
<p>配置中心 &gt; 配置分组(按服务功能分组) &gt; 配置命名空间(dev,test,prod) </p>
<p><strong>配置文件匹配方式如下格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: mall-product</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.nacos.config.server-addr=127.0.0.1:8848</span><br><span class="line">spring.cloud.nacos.config.group=product</span><br><span class="line">spring.cloud.nacos.config.file-extension=yaml</span><br><span class="line">spring.cloud.nacos.config.namespace=88ffbec9-10cb-4660-8386-e67f7325b0ba (dev)</span><br></pre></td></tr></table></figure>

<p>这样配置文件就应该是 &gt; 配置中心(127.0.0.1:8848) &gt; product分组下得 &gt; mall-product-dev.yaml</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/30/%E8%B0%B7%E7%B2%92%E5%95%86%E6%88%90-nacos&%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" data-id="ckqio8h3s0006k8ve0p4n7tez" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-README" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/30/README/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T23:17:30.453Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="github-blog"><a href="#github-blog" class="headerlink" title="github-blog"></a>github-blog</h1><p>github博客，记录各种代码方面的参考、指南、教程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/30/README/" data-id="ckqio8h3j0002k8veeydy11td" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mongodb在阿里云创建，在客户端连接流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/30/mongodb%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T23:17:30.444Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="mongodb在阿里云创建，在客户端连接流程"><a href="#mongodb在阿里云创建，在客户端连接流程" class="headerlink" title="mongodb在阿里云创建，在客户端连接流程"></a>mongodb在阿里云创建，在客户端连接流程</h1><ol>
<li>安装mongodb</li>
<li>创建数据库</li>
<li>创建数据库管理账户</li>
<li>修改配置文件</li>
<li>开放阿里云安全组端口</li>
<li>使用客户端连接</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/30/mongodb%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/" data-id="ckqio8h3m0003k8ve15g1g14j" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux 让进程在后台运行更可靠的几种方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/30/Linux%20%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%9B%B4%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T23:17:30.434Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux-技巧：让进程在后台运行更可靠的几种方法"><a href="#Linux-技巧：让进程在后台运行更可靠的几种方法" class="headerlink" title="Linux 技巧：让进程在后台运行更可靠的几种方法"></a>Linux 技巧：让进程在后台运行更可靠的几种方法</h1><p>我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。</p>
<h2 id="nohup-setsid-amp"><a href="#nohup-setsid-amp" class="headerlink" title="nohup/setsid/&amp;"></a>nohup/setsid/&amp;</h2><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？</p>
<h5 id="hangup-名称的来由"><a href="#hangup-名称的来由" class="headerlink" title="hangup 名称的来由"></a>hangup 名称的来由</h5><p>在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 时，modem 就会挂断（hang up）电话。 同理，当 modem 断开连接时，就会给终端发送 hangup 信号来通知其关闭所有子进程。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。</p>
<p><strong>1. nohup</strong></p>
<p>nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOHUP(1)            User Commands            NOHUP(1)` `NAME``    ``nohup - run a command immune to hangups, with output to a non-tty` `SYNOPSIS``    ``nohup COMMAND [ARG]...``    ``nohup OPTION` `DESCRIPTION``    ``Run COMMAND, ignoring hangup signals.` `    ``--help display this help and exit` `    ``--version``       ``output version information and exit</span><br></pre></td></tr></table></figure>

<p>可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上**”&amp;”**来将命令同时放入后台运行，也可用<code>&quot;&gt;*filename* 2&gt;&amp;1&quot;</code>来更改缺省的重定向文件名。</p>
<h5 id="nohup-示例"><a href="#nohup-示例" class="headerlink" title="nohup 示例"></a>nohup 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]# nohup ping www.ibm.com &amp;``[1] 3059``nohup: appending output to `nohup.out&#x27;``[root@pvcent107 ~]# ps -ef |grep 3059``root   3059  984 0 21:06 pts/3  00:00:00 ping www.ibm.com``root   3067  984 0 21:06 pts/3  00:00:00 grep 3059``[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure>

<p><strong>2。setsid</strong></p>
<p>nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETSID(8)         Linux Programmer’s Manual         SETSID(8)` `NAME``    ``setsid - run a program in a new session` `SYNOPSIS``    ``setsid program [ arg ... ]` `DESCRIPTION``    ``setsid runs a program in a new session.</span><br></pre></td></tr></table></figure>

<p>可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。</p>
<h5 id="setsid-示例"><a href="#setsid-示例" class="headerlink" title="setsid 示例"></a>setsid 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]# setsid ping www.ibm.com``[root@pvcent107 ~]# ps -ef |grep www.ibm.com``root   31094   1 0 07:28 ?    00:00:00 ping www.ibm.com``root   31102 29217 0 07:29 pts/4  00:00:00 grep www.ibm.com``[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure>

<p>值得注意的是，上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。请将此例与<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html#nohup">nohup 例</a>中的父 ID 做比较。</p>
<p><strong>3。&amp;</strong></p>
<p>这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。</p>
<p>当我们将”&amp;”也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过<code>jobs</code>来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。</p>
<h5 id="subshell-示例"><a href="#subshell-示例" class="headerlink" title="subshell 示例"></a>subshell 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]# (ping www.ibm.com &amp;)``[root@pvcent107 ~]# ps -ef |grep www.ibm.com``root   16270   1 0 14:13 pts/4  00:00:00 ping www.ibm.com``root   16278 15362 0 14:13 pts/4  00:00:00 grep www.ibm.com``[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure>

<p>从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。</p>
<h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><h3 id="场景：-1"><a href="#场景：-1" class="headerlink" title="场景："></a>场景：</h3><p>我们已经知道，如果事先在命令前加上 nohup 或者 setsid 就可以避免 HUP 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？</p>
<h3 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h3><p>这时想加 nohup 或者 setsid 已经为时已晚，只能通过作业调度和 disown 来解决这个问题了。让我们来看一下 disown 的帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disown [-ar] [-h] [jobspec ...]``  ``Without options, each jobspec is removed from the table of``  ``active jobs.  If the -h option is given, each jobspec is not``  ``removed from the table, but is marked so that SIGHUP is not``  ``sent to the job if the shell receives a SIGHUP. If no jobspec``  ``is present, and neither the -a nor the -r option is supplied,``  ``the current job is used. If no jobspec is supplied, the -a``  ``option means to remove or mark all jobs; the -r option without``  ``a jobspec argument restricts operation to running jobs. The``  ``return value is 0 unless a jobspec does not specify a valid``  ``job.</span><br></pre></td></tr></table></figure>

<p>可以看出，我们可以用如下方式来达成我们的目的。</p>
<h5 id="灵活运用-CTRL-z"><a href="#灵活运用-CTRL-z" class="headerlink" title="灵活运用 CTRL-z"></a>灵活运用 CTRL-z</h5><p>在我们的日常工作中，我们可以用 CTRL-z 来将当前进程挂起到后台暂停运行，执行一些别的操作，然后再用 fg 来将挂起的进程重新放回前台（也可用 bg 来将挂起的进程放在后台）继续运行。这样我们就可以在一个终端内灵活切换运行多个任务，这一点在调试代码时尤为有用。因为将代码编辑器挂起到后台再重新放回时，光标定位仍然停留在上次挂起时的位置，避免了重新定位的麻烦。</p>
<ul>
<li>用<code>disown -h *jobspec*</code>来使<strong>某个作业</strong>忽略HUP信号。</li>
<li>用<code>disown -ah </code>来使<strong>所有的作业</strong>都忽略HUP信号。</li>
<li>用<code>disown -rh </code>来使<strong>正在运行的作业</strong>忽略HUP信号。</li>
</ul>
<p>需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用<code>jobs</code>来查看它，但是依然能够用<code>ps -ef</code>查找到它。</p>
<p>但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了**”&amp;”**来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过<code>jobs</code>命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住Ctrl键的同时按住z键）了！</p>
<p>CTRL-z 的用途就是将当前进程挂起（Suspend），然后我们就可以用<code>jobs</code>命令来查询它的作业号，再用<code>bg *jobspec*</code>来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。</p>
<h5 id="disown-示例1（如果提交命令时已经用“-amp-”将命令放入后台运行，则可以直接使用“disown”）"><a href="#disown-示例1（如果提交命令时已经用“-amp-”将命令放入后台运行，则可以直接使用“disown”）" class="headerlink" title="disown 示例1（如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用“disown”）"></a>disown 示例1（如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用“disown”）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 build]# cp -r testLargeFile largeFile &amp;``[1] 4825``[root@pvcent107 build]# jobs``[1]+ Running         cp -i -r testLargeFile largeFile &amp;``[root@pvcent107 build]# disown -h %1``[root@pvcent107 build]# ps -ef |grep largeFile``root   4825  968 1 09:46 pts/4  00:00:00 cp -i -r testLargeFile largeFile``root   4853  968 0 09:46 pts/4  00:00:00 grep largeFile``[root@pvcent107 build]# logout</span><br></pre></td></tr></table></figure>

<h5 id="disown-示例2（如果提交命令时未使用“-amp-”将命令放入后台运行，可使用-CTRL-z-和“bg”将其放入后台，再使用“disown”）"><a href="#disown-示例2（如果提交命令时未使用“-amp-”将命令放入后台运行，可使用-CTRL-z-和“bg”将其放入后台，再使用“disown”）" class="headerlink" title="disown 示例2（如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 CTRL-z 和“bg”将其放入后台，再使用“disown”）"></a>disown 示例2（如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 CTRL-z 和“bg”将其放入后台，再使用“disown”）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 build]# cp -r testLargeFile largeFile2` `[1]+ Stopped         cp -i -r testLargeFile largeFile2``[root@pvcent107 build]# bg %1``[1]+ cp -i -r testLargeFile largeFile2 &amp;``[root@pvcent107 build]# jobs``[1]+ Running         cp -i -r testLargeFile largeFile2 &amp;``[root@pvcent107 build]# disown -h %1``[root@pvcent107 build]# ps -ef |grep largeFile2``root   5790 5577 1 10:04 pts/3  00:00:00 cp -i -r testLargeFile largeFile2``root   5824 5577 0 10:05 pts/3  00:00:00 grep largeFile2``[root@pvcent107 build]#</span><br></pre></td></tr></table></figure>

<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><h3 id="场景：-2"><a href="#场景：-2" class="headerlink" title="场景："></a>场景：</h3><p>我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？</p>
<h3 id="解决方法：-2"><a href="#解决方法：-2" class="headerlink" title="解决方法："></a>解决方法：</h3><p>此时最方便的方法就是 screen 了。简单的说，screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 screen 能够避免 HUP 信号的影响。我们先看一下 screen 的帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCREEN(1)                              SCREEN(1)` `NAME``    ``screen - screen manager with VT100/ANSI terminal emulation` `SYNOPSIS``    ``screen [ -options ] [ cmd [ args ] ]``    ``screen -r [[pid.]tty[.host]]``    ``screen -r sessionowner/[[pid.]tty[.host]]` `DESCRIPTION``    ``Screen is a full-screen window manager that multiplexes a physical``    ``terminal between several processes (typically interactive shells).``    ``Each virtual terminal provides the functions of a DEC VT100 terminal``    ``and, in addition, several control functions from the ISO 6429 (ECMA``    ``48, ANSI X3.64) and ISO 2022 standards (e.g. insert/delete line and``    ``support for multiple character sets). There is a scrollback history``    ``buffer for each virtual terminal and a copy-and-paste mechanism that``    ``allows moving text regions between windows.</span><br></pre></td></tr></table></figure>

<p>使用 screen 很方便，有以下几个常用选项：</p>
<ul>
<li>用<code>screen -dmS *session name*</code>来建立一个处于断开模式下的会话（并指定其会话名）。</li>
<li>用<code>screen -list </code>来列出所有会话。</li>
<li>用<code>screen -r *session name*</code>来重新连接指定会话。</li>
<li>用快捷键<code>CTRL-a d </code>来暂时断开当前会话。</li>
</ul>
<h5 id="screen-示例"><a href="#screen-示例" class="headerlink" title="screen 示例"></a>screen 示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]# screen -dmS Urumchi``[root@pvcent107 ~]# screen -list``There is a screen on:``    ``12842.Urumchi  (Detached)``1 Socket in /tmp/screens/S-root.` `[root@pvcent107 ~]# screen -r Urumchi</span><br></pre></td></tr></table></figure>

<p>当我们用“-r”连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上“nohup”或者“setsid”了。这是为什么呢？让我来看一下下面两个例子吧。</p>
<h5 id="1-未使用-screen-时新进程的进程树"><a href="#1-未使用-screen-时新进程的进程树" class="headerlink" title="1. 未使用 screen 时新进程的进程树"></a>1. 未使用 screen 时新进程的进程树</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]# ping www.google.com &amp;``[1] 9499``[root@pvcent107 ~]# pstree -H 9499``init─┬─Xvnc``   ``├─acpid``   ``├─atd``   ``├─2*[sendmail] ``   ``├─sshd─┬─sshd───bash───pstree``   ``│    └─sshd───bash───ping</span><br></pre></td></tr></table></figure>

<p>我们可以看出，未使用 screen 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 ping 进程）。</p>
<h5 id="2-使用了-screen-后新进程的进程树"><a href="#2-使用了-screen-后新进程的进程树" class="headerlink" title="2. 使用了 screen 后新进程的进程树"></a>2. 使用了 screen 后新进程的进程树</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]# screen -r Urumchi``[root@pvcent107 ~]# ping www.ibm.com &amp;``[1] 9488``[root@pvcent107 ~]# pstree -H 9488``init─┬─Xvnc``   ``├─acpid``   ``├─atd``   ``├─screen───bash───ping``   ``├─2*[sendmail]</span><br></pre></td></tr></table></figure>

<p>而使用了 screen 后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/30/Linux%20%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%9B%B4%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" data-id="ckqio8h3e0001k8ve2crp6f08" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Docker常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/30/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2021-06-29T23:17:30.417Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DeepInThought/p/10896790.html">Docker常用命令</a></h1><h1 id="1、Docker容器信息"><a href="#1、Docker容器信息" class="headerlink" title="1、Docker容器信息"></a>1、Docker容器信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##查看docker容器版本</span><br><span class="line">docker version</span><br><span class="line">##查看docker容器信息</span><br><span class="line">docker info</span><br><span class="line">##查看docker容器帮助</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>

<h1 id="2、镜像操作"><a href="#2、镜像操作" class="headerlink" title="2、镜像操作"></a>2、镜像操作</h1><p>提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。</p>
<h2 id="2-1、镜像查看"><a href="#2-1、镜像查看" class="headerlink" title="2.1、镜像查看"></a>2.1、镜像查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##列出本地images</span><br><span class="line">docker images</span><br><span class="line">##含中间映像层</span><br><span class="line">docker images -a</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521104721523-485290950.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##只显示镜像ID</span><br><span class="line">docker images -q</span><br><span class="line">##含中间映像层</span><br><span class="line">docker images -qa   </span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521104927909-600452122.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##显示镜像摘要信息(DIGEST列)</span><br><span class="line">docker images --digests</span><br><span class="line">##显示镜像完整信息</span><br><span class="line">docker images --no-trunc</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521105114405-1780655005.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc  显示完整的提交记录；-q  仅列出提交记录ID</span><br><span class="line">docker history -H redis</span><br></pre></td></tr></table></figure>

<h2 id="2-2、镜像搜索"><a href="#2-2、镜像搜索" class="headerlink" title="2.2、镜像搜索"></a>2.2、镜像搜索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##搜索仓库MySQL镜像</span><br><span class="line">docker search mysql</span><br><span class="line">## --filter=stars=600：只显示 starts&gt;=600 的镜像</span><br><span class="line">docker search --filter=stars=600 mysql</span><br><span class="line">## --no-trunc 显示镜像完整 DESCRIPTION 描述</span><br><span class="line">docker search --no-trunc mysql</span><br><span class="line">## --automated ：只列出 AUTOMATED=OK 的镜像</span><br><span class="line">docker search  --automated mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521110514156-691788920.png" alt="img"></p>
<h2 id="2-3、镜像下载"><a href="#2-3、镜像下载" class="headerlink" title="2.3、镜像下载"></a>2.3、镜像下载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##下载Redis官方最新镜像，相当于：docker pull redis:latest</span><br><span class="line">docker pull redis</span><br><span class="line">##下载仓库所有Redis镜像</span><br><span class="line">docker pull -a redis</span><br><span class="line">##下载私人仓库镜像</span><br><span class="line">docker pull bitnami/redis</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521112716615-10141164.png" alt="img"></p>
<h2 id="2-4、镜像删除"><a href="#2-4、镜像删除" class="headerlink" title="2.4、镜像删除"></a>2.4、镜像删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##单个镜像删除，相当于：docker rmi redis:latest</span><br><span class="line">docker rmi redis</span><br><span class="line">##强制删除(针对基于镜像有运行的容器进程)</span><br><span class="line">docker rmi -f redis</span><br><span class="line">##多个镜像删除，不同镜像间以空格间隔</span><br><span class="line">docker rmi -f redis tomcat nginx</span><br><span class="line">##删除本地全部镜像</span><br><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure>

<h2 id="2-5、镜像构建"><a href="#2-5、镜像构建" class="headerlink" title="2.5、镜像构建"></a>2.5、镜像构建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##（1）编写dockerfile</span><br><span class="line">cd /docker/dockerfile</span><br><span class="line">vim mycentos</span><br><span class="line">##（2）构建docker镜像</span><br><span class="line">docker build -f /docker/dockerfile/mycentos -t mycentos:1.1</span><br></pre></td></tr></table></figure>

<h1 id="3、容器操作"><a href="#3、容器操作" class="headerlink" title="3、容器操作"></a>3、容器操作</h1><p>提示：对于容器的操作可使用CONTAINER ID 或 NAMES。</p>
<h2 id="3-1、容器启动"><a href="#3-1、容器启动" class="headerlink" title="3.1、容器启动"></a>3.1、容器启动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称</span><br><span class="line">docker run -i -t --name mycentos</span><br><span class="line">##后台启动容器，参数：-d  已守护方式启动容器</span><br><span class="line">docker run -d mycentos</span><br></pre></td></tr></table></figure>

<p>注意：此时使用”docker ps -a”会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##启动一个或多个已经被停止的容器</span><br><span class="line">docker start redis</span><br><span class="line">##重启容器</span><br><span class="line">docker restart redis</span><br></pre></td></tr></table></figure>

<h2 id="3-2、容器进程"><a href="#3-2、容器进程" class="headerlink" title="3.2、容器进程"></a>3.2、容器进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br><span class="line">##列出redis容器中运行进程</span><br><span class="line">docker top redis</span><br><span class="line">##查看所有运行容器的进程信息</span><br><span class="line">for i in  `docker ps |grep Up|awk &#x27;&#123;print $1&#125;&#x27;`;do echo \ &amp;&amp;docker top $i; done</span><br></pre></td></tr></table></figure>

<h2 id="3-3、容器日志"><a href="#3-3、容器日志" class="headerlink" title="3.3、容器日志"></a>3.3、容器日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##查看redis容器日志，默认参数</span><br><span class="line">docker logs rabbitmq</span><br><span class="line">##查看redis容器日志，参数：-f  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；</span><br><span class="line">docker logs -f -t --tail=20 redis</span><br><span class="line">##查看容器redis从2019年05月21日后的最新10条日志。</span><br><span class="line">docker logs --since=&quot;2019-05-21&quot; --tail=10 redis</span><br></pre></td></tr></table></figure>

<h2 id="3-4、容器的进入与退出"><a href="#3-4、容器的进入与退出" class="headerlink" title="3.4、容器的进入与退出"></a>3.4、容器的进入与退出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">##使用run方式在创建时进入</span><br><span class="line">docker run -it centos /bin/bash</span><br><span class="line">##关闭容器并退出</span><br><span class="line">exit</span><br><span class="line">##仅退出容器，不关闭</span><br><span class="line">快捷键：Ctrl + P + Q</span><br><span class="line">##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false  确保CTRL-D或CTRL-C不会关闭容器</span><br><span class="line">docker attach --sig-proxy=false centos </span><br><span class="line">##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端</span><br><span class="line">docker exec -i -t  centos /bin/bash</span><br><span class="line">##以交互模式在容器中执行命令，结果返回到当前终端屏幕</span><br><span class="line">docker exec -i -t centos ls -l /tmp</span><br><span class="line">##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端</span><br><span class="line">docker exec -d centos  touch cache.txt </span><br></pre></td></tr></table></figure>

<h2 id="3-5、查看容器"><a href="#3-5、查看容器" class="headerlink" title="3.5、查看容器"></a>3.5、查看容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##查看正在运行的容器</span><br><span class="line">docker ps</span><br><span class="line">##查看正在运行的容器的ID</span><br><span class="line">docker ps -q</span><br><span class="line">##查看正在运行+历史运行过的容器</span><br><span class="line">docker ps -a</span><br><span class="line">##显示运行容器总文件大小</span><br><span class="line">docker ps -s</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521132255698-500560462.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521133039811-1994116017.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##显示最近创建容器</span><br><span class="line">docker ps -l</span><br><span class="line">##显示最近创建的3个容器</span><br><span class="line">docker ps -n 3</span><br><span class="line">##不截断输出</span><br><span class="line">docker ps --no-trunc </span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1659331/201905/1659331-20190521132741451-294716433.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##获取镜像redis的元信息</span><br><span class="line">docker inspect redis</span><br><span class="line">##获取正在运行的容器redis的 IP</span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; redis</span><br></pre></td></tr></table></figure>

<h2 id="3-6、容器的停止与删除"><a href="#3-6、容器的停止与删除" class="headerlink" title="3.6、容器的停止与删除"></a>3.6、容器的停止与删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">##停止一个运行中的容器</span><br><span class="line">docker stop redis</span><br><span class="line">##杀掉一个运行中的容器</span><br><span class="line">docker kill redis</span><br><span class="line">##删除一个已停止的容器</span><br><span class="line">docker rm redis</span><br><span class="line">##删除一个运行中的容器</span><br><span class="line">docker rm -f redis</span><br><span class="line">##删除多个容器</span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br><span class="line">## -l 移除容器间的网络连接，连接名为 db</span><br><span class="line">docker rm -l db </span><br><span class="line">## -v 删除容器，并删除容器挂载的数据卷</span><br><span class="line">docker rm -v redis</span><br></pre></td></tr></table></figure>

<h2 id="3-7、生成镜像"><a href="#3-7、生成镜像" class="headerlink" title="3.7、生成镜像"></a>3.7、生成镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停</span><br><span class="line">docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID]  myredis:v1.1</span><br></pre></td></tr></table></figure>

<h2 id="3-8、容器与主机间的数据拷贝"><a href="#3-8、容器与主机间的数据拷贝" class="headerlink" title="3.8、容器与主机间的数据拷贝"></a>3.8、容器与主机间的数据拷贝</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##将rabbitmq容器中的文件copy至本地路径</span><br><span class="line">docker cp rabbitmq:/[container_path] [local_path]</span><br><span class="line">##将主机文件copy至rabbitmq容器</span><br><span class="line">docker cp [local_path] rabbitmq:/[container_path]/</span><br><span class="line">##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）</span><br><span class="line">docker cp [local_path] rabbitmq:/[container_path]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/30/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="ckqio8h2u0000k8ve6lik4c4d" data-title="" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-在vagrant创建的虚拟机中安装redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/18/%E5%9C%A8vagrant%E5%88%9B%E5%BB%BA%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%AE%89%E8%A3%85redis/" class="article-date">
  <time class="dt-published" datetime="2021-06-18T15:18:21.267Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/github-blog/2021/06/18/%E5%9C%A8vagrant%E5%88%9B%E5%BB%BA%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%AE%89%E8%A3%85redis/">在vagrant创建的虚拟机中安装redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、安装gcc依赖</p>
<p>由于 redis 是用 C 语言开发，安装之前必先确认是否安装 gcc 环境（gcc -v），如果没有安装，执行以下命令进行安装</p>
<p> [root@localhost local]# yum install -y gcc </p>
<p>二、下载并解压安装包</p>
<p>[root@localhost local]# wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-5.0.3.tar.gz">http://download.redis.io/releases/redis-5.0.3.tar.gz</a></p>
<p>[root@localhost local]# tar -zxvf redis-5.0.3.tar.gz</p>
<p>三、cd切换到redis解压目录下，执行编译</p>
<p>[root@localhost local]# cd redis-5.0.3</p>
<p>[root@localhost redis-5.0.3]# make</p>
<p>四、安装并指定安装目录</p>
<p>[root@localhost redis-5.0.3]# make install PREFIX=/usr/local/redis</p>
<p>五、启动服务</p>
<p>5.1前台启动</p>
<p>[root@localhost redis-5.0.3]# cd /usr/local/redis/bin/</p>
<p>[root@localhost bin]# ./redis-server</p>
<p>5.2后台启动</p>
<p>从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录</p>
<p>[root@localhost bin]# cp /usr/local/redis-5.0.3/redis.conf /usr/local/redis/bin/</p>
<p>修改 redis.conf 文件，把 daemonize no 改为 daemonize yes</p>
<p>[root@localhost bin]# vi redis.conf</p>
<p>后台启动</p>
<p>[root@localhost bin]# ./redis-server redis.conf</p>
<p>六、设置开机启动</p>
<p>添加开机启动服务</p>
<p>[root@localhost bin]# vi /etc/systemd/system/redis.service</p>
<p>复制粘贴以下内容：</p>
<p>复制代码<br>[Unit]<br>Description=redis-server<br>After=network.target</p>
<p>[Service]<br>Type=forking<br>ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf<br>PrivateTmp=true</p>
<p>[Install]<br>WantedBy=multi-user.target</p>
<p>复制代码<br>注意：ExecStart配置成自己的路径 </p>
<p>设置开机启动</p>
<p>[root@localhost bin]# systemctl daemon-reload</p>
<p>[root@localhost bin]# systemctl start redis.service</p>
<p>[root@localhost bin]# systemctl enable redis.service</p>
<p>创建 redis 命令软链接</p>
<p>[root@localhost ~]# ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis</p>
<p>测试 redis</p>
<p>服务操作命令</p>
<p>systemctl start redis.service   #启动redis服务</p>
<p>systemctl stop redis.service   #停止redis服务</p>
<p>systemctl restart redis.service   #重新启动服务</p>
<p>systemctl status redis.service   #查看服务当前状态</p>
<p>systemctl enable redis.service   #设置开机自启动</p>
<p>systemctl disable redis.service   #停止开机自启动</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/18/%E5%9C%A8vagrant%E5%88%9B%E5%BB%BA%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%AE%89%E8%A3%85redis/" data-id="ckqio8h3q0005k8veadsph161" data-title="在vagrant创建的虚拟机中安装redis" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-安装vagrant" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/github-blog/2021/06/18/%E5%AE%89%E8%A3%85vagrant/" class="article-date">
  <time class="dt-published" datetime="2021-06-18T15:15:34.008Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/github-blog/2021/06/18/%E5%AE%89%E8%A3%85vagrant/">安装vagrant</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1）安装vagrant"><a href="#1）安装vagrant" class="headerlink" title="1）安装vagrant"></a>1）安装vagrant</h3><h3 id="2）安装Centos7"><a href="#2）安装Centos7" class="headerlink" title="2）安装Centos7"></a>2）安装Centos7</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vagrant init centos/7</span></span><br><span class="line">A `Vagrantfile` has been placed in this directory. You are now</span><br><span class="line">ready to `vagrant up` your first virtual environment! Please read</span><br><span class="line">the comments in the Vagrantfile as well as documentation on</span><br><span class="line">`vagrantup.com` for more information on using Vagrant.</span><br></pre></td></tr></table></figure>

<p>执行完上面的命令后，会在用户的家目录下生成Vagrantfile文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vagrant up</span></span><br><span class="line">Bringing machine &#x27;default&#x27; up with &#x27;virtualbox&#x27; provider...</span><br><span class="line">==&gt; default: Box &#x27;centos/7&#x27; could not be found. Attempting to find and install...</span><br><span class="line">    default: Box Provider: virtualbox</span><br><span class="line">    default: Box Version: &gt;= 0</span><br><span class="line">==&gt; default: Loading metadata for box &#x27;centos/7&#x27;</span><br><span class="line">    default: URL: https://vagrantcloud.com/centos/7</span><br><span class="line">==&gt; default: Adding box &#x27;centos/7&#x27; (v1905.1) for provider: virtualbox</span><br><span class="line">    default: Downloading: https://vagrantcloud.com/centos/boxes/7/versions/1905.1/providers/virtualbox.box</span><br><span class="line">    default: Download redirected to host: cloud.centos.org</span><br><span class="line">    default: Progress: 0% (Rate: 6717/s, Estimated time remaining: 7:33:42)</span><br></pre></td></tr></table></figure>

<p>下载镜像过程比较漫长，也可以采用先用下载工具下载到本地后，然后使用“ vagrant box add ”添加，再“vagrant up”即可</p>
<p>！！！注意：最好使用在线安装，这种本地安装的方式会出现各种各样的问题。轻易不要尝试！！！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将下载的镜像添加到virtualBox中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vagrant box add centos/7 E:\迅雷下载\CentOS-7-x86_64-Vagrant-1905_01.VirtualBox.box</span></span><br><span class="line">==&gt; box: Box file was not detected as metadata. Adding it directly...</span><br><span class="line">==&gt; box: Adding box &#x27;centos/7&#x27; (v0) for provider:</span><br><span class="line">    box: Unpacking necessary files from: file:///E:/%D1%B8%C0%D7%CF%C2%D4%D8/CentOS-7-x86_64-Vagrant-1905_01.VirtualBox.box</span><br><span class="line">    box:</span><br><span class="line">==&gt; box: Successfully added box &#x27;centos/7&#x27; (v0) for &#x27;virtualbox&#x27;!</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vagrant up</span></span><br><span class="line">Bringing machine &#x27;default&#x27; up with &#x27;virtualbox&#x27; provider...</span><br><span class="line">==&gt; default: Importing base box &#x27;centos/7&#x27;...</span><br><span class="line">==&gt; default: Matching MAC address for NAT networking...</span><br><span class="line">==&gt; default: Setting the name of the VM: Administrator_default_1588497928070_24634</span><br><span class="line">==&gt; default: Clearing any previously set network interfaces...</span><br><span class="line">==&gt; default: Preparing network interfaces based on configuration...</span><br><span class="line">    default: Adapter 1: nat</span><br><span class="line">    default: Adapter 2: hostonly</span><br><span class="line">==&gt; default: Forwarding ports...</span><br><span class="line">    default: 22 (guest) =&gt; 2222 (host) (adapter 1)</span><br><span class="line">==&gt; default: Booting VM...</span><br><span class="line">==&gt; default: Waiting for machine to boot. This may take a few minutes...</span><br><span class="line">    default: SSH address: 127.0.0.1:2222</span><br><span class="line">    default: SSH username: vagrant</span><br><span class="line">    default: SSH auth method: private key</span><br><span class="line">    default:</span><br><span class="line">    default: Vagrant insecure key detected. Vagrant will automatically replace</span><br><span class="line">    default: this with a newly generated keypair for better security.</span><br><span class="line">    default:</span><br><span class="line">    default: Inserting generated public key within guest...</span><br><span class="line">    default: Removing insecure key from the guest if it&#x27;s present...</span><br><span class="line">    default: Key inserted! Disconnecting and reconnecting using new SSH key...</span><br><span class="line">==&gt; default: Machine booted and ready!</span><br><span class="line">==&gt; default: Checking for guest additions in VM...</span><br><span class="line">    default: No guest additions were detected on the base box for this VM! Guest</span><br><span class="line">    default: additions are required for forwarded ports, shared folders, host only</span><br><span class="line">    default: networking, and more. If SSH fails on this machine, please install</span><br><span class="line">    default: the guest additions and repackage the box to continue.</span><br><span class="line">    default:</span><br><span class="line">    default: This is not an error message; everything may continue to work properly,</span><br><span class="line">    default: in which case you may ignore this message.</span><br><span class="line">==&gt; default: Configuring and enabling network interfaces...</span><br><span class="line">==&gt; default: Rsyncing folder: /cygdrive/c/Users/Administrator/ =&gt; /vagrant</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>vagrant ssh 开启SSH，并登陆到centos7</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vagrant ssh</span></span><br><span class="line">[vagrant@localhost ~]$ ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0</span><br><span class="line">       valid_lft 86091sec preferred_lft 86091sec</span><br><span class="line">    inet6 fe80::5054:ff:fe8a:fee6/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:d1:76:f6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.56.102/24 brd 192.168.56.255 scope global noprefixroute dynamic eth1</span><br><span class="line">       valid_lft 892sec preferred_lft 892sec</span><br><span class="line">    inet6 fe80::8c94:1942:ba09:2458/64 scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[vagrant@localhost ~]$</span><br></pre></td></tr></table></figure>









<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ipconfig</span><br><span class="line"></span><br><span class="line">Windows IP 配置</span><br><span class="line"></span><br><span class="line">以太网适配器 VirtualBox Host-Only Network:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::a00c:1ffa:a39a:c8c2%16</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 192.168.56.1</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br></pre></td></tr></table></figure>







<p>配置网络信息，打开”Vagrantfile”文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot;</span><br></pre></td></tr></table></figure>



<p>修改完成后，重启启动vagrant</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant reload</span><br></pre></td></tr></table></figure>

<p>检查宿主机和virtualBox之间的通信是否正常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ ping 192.168.43.43                                                                                                         PING 192.168.43.43 (192.168.43.43) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.43.43: icmp_seq=1 ttl=127 time=0.533 ms</span><br><span class="line">64 bytes from 192.168.43.43: icmp_seq=2 ttl=127 time=0.659 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.43.43 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.533/0.596/0.659/0.063 ms</span><br><span class="line">[vagrant@localhost ~]$</span><br><span class="line">[vagrant@localhost ~]$</span><br><span class="line">[vagrant@localhost ~]$ ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (112.80.248.76) 56(84) bytes of data.</span><br><span class="line">64 bytes from 112.80.248.76 (112.80.248.76): icmp_seq=1 ttl=53 time=56.1 ms</span><br><span class="line">64 bytes from 112.80.248.76 (112.80.248.76): icmp_seq=2 ttl=53 time=58.5 ms</span><br><span class="line">64 bytes from 112.80.248.76 (112.80.248.76): icmp_seq=3 ttl=53 time=53.4 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启远程登陆，修改“/etc/ssh/sshd_config”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin yes </span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>

<p>然后重启SSHD</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<p>使用Xshell或SecureCRT进行远程连接。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://guotianhao.github.io/github-blog/2021/06/18/%E5%AE%89%E8%A3%85vagrant/" data-id="ckqio8h3x000ak8ve8zse5p1t" data-title="安装vagrant" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/github-blog/page/2/">2</a><a class="extend next" rel="next" href="/github-blog/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/github-blog/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/github-blog/2021/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/github-blog/2021/06/30/%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/github-blog/2021/06/30/%E8%B0%B7%E7%B2%92%E5%95%86%E6%88%90%E7%AC%94%E8%AE%B0-docker%20mysql&redis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/github-blog/2021/06/30/%E8%B0%B7%E7%B2%92%E5%95%86%E6%88%90-nacos&%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">(no title)</a>
          </li>
        
          <li>
            <a href="/github-blog/2021/06/30/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 郭天昊<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/github-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/github-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/github-blog/js/jquery-3.4.1.min.js"></script>



  
<script src="/github-blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/github-blog/js/script.js"></script>





  </div>
</body>
</html>